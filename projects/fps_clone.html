<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minimal DOOM Clone — Floorcasting</title>
<style>
  html,body{margin:0;padding:0;background:#000;}
  canvas{
    display:block;
    width:640px;
    height:480px;
    image-rendering:pixelated;
    cursor:crosshair;
  }
  #hint { position: fixed; left: 8px; bottom: 8px; color:#ccc; font:12px/1 monospace; background:rgba(0,0,0,0.4); padding:6px 8px; border-radius:6px;}
</style>
</head>
<body>
<canvas id="game" width="640" height="480"></canvas>
<div id="hint">Backtick (`) = Dev mode, M = pointer lock + mouse look, L = Layer diagram</div>

<script>
/* DOOM-lite — 640x480, floorcasting & dev features */

// --- Canvas & context ---
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d',{alpha:false});
const W=canvas.width,H=canvas.height;

// --- Config / Units ---
const PIXELS_PER_FT=100,PLAYER_HEIGHT_FT=5.67,CEILING_HEIGHT_FT=8,GRAVITY=12,MAX_RAY_DIST=24;

// --- Map ---
const map=[
[1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,1],
[1,0,1,0,1,0,1,0,0,1],
[1,0,0,0,0,0,0,1,0,1],
[1,0,1,0,0,1,0,0,0,1],
[1,0,0,0,1,0,0,0,0,1],
[1,0,0,0,0,0,1,0,0,1],
[1,0,0,1,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1]
];
const MAP_W=map[0].length,MAP_H=map.length;

// --- Player ---
const player={x:3.5,y:4.5,angle:0,pitch:0,radius:0.18,eyeOffset:0,verticalVel:0,onFloor:true};

// --- Controls & state ---
const keys={};
let devMode=false,showLayerDiagram=false;
const settings={walkSpeed:4,jumpHeight:2,jumpDuration:0.5,crouchDepth:1.5,crouchSpeed:5,mouseSensitivity:0.003};
const hintDiv=document.getElementById('hint');
function updateHint(){hintDiv.style.display=devMode?'none':'block';}
updateHint();

// --- Input ---
window.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true; keys[e.key]=true;
  if(e.key==='`'){devMode=!devMode;updateHint();}
  if(e.key.toLowerCase()==='l') showLayerDiagram=!showLayerDiagram;
  if(e.key.toLowerCase()==='m'&&!devMode){
    if(document.pointerLockElement===canvas) document.exitPointerLock();
    else canvas.requestPointerLock();
  }
  if(devMode){
    switch(e.key){
      case '1':settings.jumpHeight+=0.1;break;
      case '2':settings.jumpHeight=Math.max(0.1,settings.jumpHeight-0.1);break;
      case '3':settings.jumpDuration+=0.05;break;
      case '4':settings.jumpDuration=Math.max(0.05,settings.jumpDuration-0.05);break;
      case '5':settings.crouchSpeed+=0.5;break;
      case '6':settings.crouchSpeed=Math.max(0.5,settings.crouchSpeed-0.5);break;
      case '7':settings.mouseSensitivity+=0.0005;break;
      case '8':settings.mouseSensitivity=Math.max(0.0005,settings.mouseSensitivity-0.0005);break;
    }
  }
});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;keys[e.key]=false;});
document.addEventListener('mousemove',e=>{
  if(document.pointerLockElement===canvas){
    player.angle+=e.movementX*settings.mouseSensitivity;
    player.pitch-=e.movementY*settings.mouseSensitivity;
    const limit=Math.PI/2-0.01;
    player.pitch=Math.max(-limit,Math.min(limit,player.pitch));
  }
});

// --- Helpers ---
function inMap(x,y){return x>=0&&y>=0&&x<MAP_W&&y<MAP_H;}
function tileAt(x,y){if(!inMap(Math.floor(x),Math.floor(y))) return 1; return map[Math.floor(y)][Math.floor(x)];}

// --- Raycast ---
function castRay(px,py,angle){
  let rx=px,ry=py,step=0.05,traveled=0;
  while(traveled<MAX_RAY_DIST){
    rx+=Math.cos(angle)*step;
    ry+=Math.sin(angle)*step;
    traveled+=step;
    const tx=Math.floor(rx),ty=Math.floor(ry);
    if(!inMap(tx,ty)) return MAX_RAY_DIST;
    if(map[ty][tx]===1) return Math.hypot(rx-px,ry-py);
  }
  return MAX_RAY_DIST;
}

// --- Collision ---
function isColliding(x,y){
  const r=player.radius;
  const minX=Math.floor(x-r),maxX=Math.floor(x+r);
  const minY=Math.floor(y-r),maxY=Math.floor(y+r);
  for(let yy=minY;yy<=maxY;yy++){
    for(let xx=minX;xx<=maxX;xx++){
      if(!inMap(xx,yy)) return true;
      if(map[yy][xx]===1) return true;
    }
  }
  return false;
}

// --- Dev map editing ---
canvas.addEventListener('click',e=>{
  if(!devMode) return;
  const scale=18,margin=10,mapWpx=MAP_W*scale,mapHpx=MAP_H*scale;
  const offX=canvas.width-mapWpx-margin,offY=canvas.height-mapHpx-margin;
  const mx=e.clientX,my=e.clientY;
  if(mx>=offX&&mx<offX+mapWpx&&my>=offY&&my<offY+mapHpx){
    const gx=Math.floor((mx-offX)/scale),gy=Math.floor((my-offY)/scale);
    if(inMap(gx,gy)&&!(Math.floor(player.x)===gx&&Math.floor(player.y)===gy)) map[gy][gx]=map[gy][gx]===1?0:1;
  }
});

// --- Physics & Input ---
function handleInput(delta){
  const speed=settings.walkSpeed*delta;
  let dx=0,dy=0;
  if(keys['w']||keys['arrowup']){dx+=Math.cos(player.angle)*speed; dy+=Math.sin(player.angle)*speed;}
  if(keys['s']||keys['arrowdown']){dx-=Math.cos(player.angle)*speed; dy-=Math.sin(player.angle)*speed;}
  if(keys['a']||keys['arrowleft']){dx+=Math.sin(player.angle)*speed; dy-=Math.cos(player.angle)*speed;}
  if(keys['d']||keys['arrowright']){dx-=Math.sin(player.angle)*speed; dy+=Math.cos(player.angle)*speed;}

  const newX=player.x+dx,newY=player.y+dy;
  if(!isColliding(newX,player.y)) player.x=newX;
  if(!isColliding(player.x,newY)) player.y=newY;

  // Jump
  if((keys[' ']||keys['space'])&&player.onFloor){
    const t=settings.jumpDuration,h=settings.jumpHeight;
    const v0=-(h+0.5*GRAVITY*t*t)/t;
    player.verticalVel=v0;
    player.onFloor=false;
  }
  player.verticalVel+=GRAVITY*delta;
  player.eyeOffset+=player.verticalVel*delta;
  if(player.eyeOffset>=0){player.eyeOffset=0;player.verticalVel=0;player.onFloor=true;}

  // Crouch
  if(keys['control']) player.eyeOffset=Math.max(-settings.crouchDepth,player.eyeOffset-settings.crouchSpeed*delta);
  else player.eyeOffset=Math.min(0,player.eyeOffset+settings.crouchSpeed*delta);
}

// --- Rendering ---
function renderWorld(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  const horizon=Math.floor(H/2+Math.tan(player.pitch)*H/2-player.eyeOffset*PIXELS_PER_FT);

  // Ceiling
  ctx.fillStyle='#777'; ctx.fillRect(0,0,W,Math.max(0,Math.min(horizon,H)));

  // Walls
  const fov=Math.PI/3;
  const halfH=H/2,projPlaneDist=halfH/Math.tan(fov/2);
  const eyeHeight=PLAYER_HEIGHT_FT+player.eyeOffset;
  const MIN_DIST=0.15;

  for(let col=0;col<W;col+=2){ // cast every 2 columns for speed
    const rayAngle=player.angle-fov/2+(col/W)*fov;
    const dist=castRay(player.x,player.y,rayAngle);
    const corrected=Math.max(dist*Math.cos(rayAngle-player.angle),MIN_DIST);
    const wallHeightPx=Math.min(H,(H/corrected)*0.8);
    const pitchOffsetPx=Math.tan(player.pitch)*halfH-player.eyeOffset*PIXELS_PER_FT;
    const half=wallHeightPx/2;
    const yTop=Math.max(0,Math.floor(horizon-half+pitchOffsetPx));
    const yBottom=Math.min(H,Math.floor(horizon+half+pitchOffsetPx));
    const shade=Math.max(18,Math.min(255,Math.floor(200/corrected)));
    ctx.fillStyle=`rgb(${shade},${shade},${shade})`;
    if(yBottom>yTop) ctx.fillRect(col,yTop,2,Math.max(0,yBottom-yTop));
  }

  // Floor-casting
  const leftAngle=player.angle-fov/2,rightAngle=player.angle+fov/2;
  const rayDirLeft={x:Math.cos(leftAngle),y:Math.sin(leftAngle)};
  const rayDirRight={x:Math.cos(rightAngle),y:Math.sin(rightAngle)};
  for(let screenY=Math.max(0,horizon);screenY<H;screenY++){
    const rowDistance=(eyeHeight*projPlaneDist)/(screenY-horizon);
    const stepX=(rayDirRight.x-rayDirLeft.x)*(rowDistance/W);
    const stepY=(rayDirRight.y-rayDirLeft.y)*(rowDistance/W);
    let floorX=player.x+rayDirLeft.x*rowDistance;
    let floorY=player.y+rayDirLeft.y*rowDistance;
    for(let col=0;col<W;col++){
      const mapX=Math.floor(floorX),mapY=Math.floor(floorY);
      let base=inMap(mapX,mapY)?(((mapX+mapY)&1)===0?70:50):30;
      const brightness=Math.max(10,Math.min(255,Math.floor(base+160/Math.max(0.5,rowDistance))));
      ctx.fillStyle=`rgb(${brightness},${brightness},${brightness})`;
      ctx.fillRect(col,screenY,1,1);
      floorX+=stepX; floorY+=stepY;
    }
  }
}

// --- HUD & overlays ---
function renderHUD(){
  const scale=18,margin=10,mapWpx=MAP_W*scale,mapHpx=MAP_H*scale;
  const offX=W-mapWpx-margin,offY=H-mapHpx-margin;
  ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(offX-4,offY-4,mapWpx+8,mapHpx+8);
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      ctx.fillStyle=map[y][x]===1?'#111':'#ddd';
      ctx.fillRect(offX+x*scale,offY+y*scale,scale-1,scale-1);
    }
  }
  const px=offX+player.x*scale,py=offY+player.y*scale;
  ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(px,py,Math.max(2,scale/4),0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='red'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+Math.cos(player.angle)*scale,py+Math.sin(player.angle)*scale); ctx.stroke();
  ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(W-220,H-80,210,70);
  ctx.fillStyle='cyan'; ctx.font='14px monospace';
  ctx.fillText(`Eye level: ${(PLAYER_HEIGHT_FT+player.eyeOffset).toFixed(2)} ft`,W-210,H-50);
  ctx.fillStyle='white';
  ctx.fillText(`Pos: ${player.x.toFixed(2)}, ${player.y.toFixed(2)}`,W-210,H-32);
  ctx.fillText(`Angle: ${player.angle.toFixed(2)} rad`,W-210,H-16);
}

function renderFeaturesOverlay(){
  const margin=10,overlayW=300,overlayH=180;
  const x=W-overlayW-margin,y=margin;
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(x,y,overlayW,overlayH);
  ctx.fillStyle='white'; ctx.font='14px monospace';
  const line=i=>y+20+i*18;
  ctx.fillText('FEATURES (Toggle key):',x+10,line(0));
  ctx.fillStyle=devMode?'lime':'red';
  ctx.fillText('Dev Mode (`): '+(devMode?'ON':'OFF'),x+10,line(1));
  ctx.fillStyle=(!devMode&&document.pointerLockElement===canvas)?'lime':'red';
  ctx.fillText('Mouse Look (M): '+((!devMode&&document.pointerLockElement===canvas)?'ON':'OFF'),x+10,line(2));
  ctx.fillStyle=keys[' ']?'lime':'red';
  ctx.fillText('Jump (Space)',x+10,line(3));
  ctx.fillStyle=keys['control']?'lime':'red';
  ctx.fillText('Crouch (Ctrl)',x+10,line(4));
  ctx.fillStyle=showLayerDiagram?'lime':'red';
  ctx.fillText('Layer Diagram (L): '+(showLayerDiagram?'ON':'OFF'),x+10,line(5));
  ctx.fillStyle='cyan';
  ctx.fillText(`Eye Level: ${(PLAYER_HEIGHT_FT+player.eyeOffset).toFixed(2)} ft`,x+10,line(6));
  ctx.fillStyle='white';
  ctx.fillText(`Floor-Ceiling: ${CEILING_HEIGHT_FT} ft`,x+10,line(7));
}

function renderSettingsOverlay(){
  if(!devMode) return;
  const x=10,y=10;
  ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(x,y,280,140);
  ctx.fillStyle='white'; ctx.font='14px monospace';
  ctx.fillText('DEV SETTINGS:',x+10,y+20);
  ctx.fillStyle='yellow';
  ctx.fillText(`Jump Height (ft): ${settings.jumpHeight.toFixed(2)} (1/2)`,x+10,y+40);
  ctx.fillText(`Jump Duration (s): ${settings.jumpDuration.toFixed(2)} (3/4)`,x+10,y+60);
  ctx.fillText(`Crouch Depth (ft): ${settings.crouchDepth.toFixed(2)} (5/6)`,x+10,y+80);
  ctx.fillText(`Mouse Sensitivity: ${settings.mouseSensitivity.toFixed(4)} (7/8)`,x+10,y+100);
  ctx.fillStyle='white'; ctx.fillText('Use 1-8 to tweak',x+10,y+120);
}

function renderLayerDiagram(){
  if(!showLayerDiagram) return;
  ctx.fillStyle='rgba(0,0,255,0.18)'; ctx.fillRect(0,0,W,H);
  const scale=18,mapWpx=MAP_W*scale,mapHpx=MAP_H*scale;
  const offX=W-mapWpx-10,offY=H-mapHpx-10;
  ctx.fillStyle='rgba(0,255,0,0.25)'; ctx.fillRect(offX,offY,mapWpx,mapHpx);
  ctx.fillStyle='black'; ctx.font='14px monospace'; ctx.fillText('HUD',offX+6,offY+18);
  ctx.fillStyle='rgba(255,255,0,0.22)'; ctx.fillRect(W-310,10,300,180);
  ctx.fillStyle='black'; ctx.fillText('Feature Overlay',W-300,30);
  ctx.fillStyle='rgba(255,165,0,0.22)'; ctx.fillRect(10,10,280,140);
  ctx.fillStyle='black'; ctx.fillText('Settings Overlay',20,30);
  ctx.fillStyle='white'; ctx.font='16px monospace'; ctx.fillText('Layer Diagram ACTIVE (toggle L)',20,20);
}

// --- Main loop ---
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  handleInput(dt);
  renderWorld();
  renderHUD();
  renderFeaturesOverlay();
  renderSettingsOverlay();
  renderLayerDiagram();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
