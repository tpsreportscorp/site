<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minimal DOOM Clone — Floorcasting</title>
<style>
  html,body{margin:0;padding:0;height:100%;background:#000;}
  canvas{display:block;width:100%;height:100%;image-rendering:pixelated;cursor:crosshair;}
  #hint { position: fixed; left: 8px; bottom: 8px; color:#ccc; font:12px/1 monospace; background:rgba(0,0,0,0.4); padding:6px 8px; border-radius:6px;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hint">Backtick (`) = Dev mode, M = pointer lock + mouse look, L = Layer diagram</div>

<script>
/* Clean DOOM-lite with proper floor-casting (perspective floor) */

// --- Canvas & resize ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
function resize(){ canvas.width = Math.floor(window.innerWidth); canvas.height = Math.floor(window.innerHeight); }
window.addEventListener('resize', resize);
resize();

// --- Config / Units ---
const PIXELS_PER_FT = 100;            // cosmetic scale for eye offset rendering
const PLAYER_HEIGHT_FT = 5.67;        // player total height
const CEILING_HEIGHT_FT = 8;          // ceiling / wall height
const GRAVITY = 12;                   // ft/s^2
const MAX_RAY_DIST = 24;              // tiles for raycasting

// --- Map (1 = wall, 0 = empty) ---
const map = [
  [1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,1,0,1,0,1,0,0,1],
  [1,0,0,0,0,0,0,1,0,1],
  [1,0,1,0,0,1,0,0,0,1],
  [1,0,0,0,1,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,1],
  [1,0,0,1,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1]
];
const MAP_W = map[0].length;
const MAP_H = map.length;

// --- Player ---
const player = {
  x: 3.5,
  y: 4.5,
  angle: 0,
  pitch: 0,
  radius: 0.18,
  eyeOffset: 0,     // vertical eye offset in feet (0 = standing on floor; negative = up)
  verticalVel: 0,   // ft/s (negative = upward)
  onFloor: true
};

// --- Controls & state ---
const keys = {};
let devMode = false;
let showLayerDiagram = false;
const settings = {
  walkSpeed: 4.0,      // ft/s (we treat 1 tile ~= 1 ft for movement)
  jumpHeight: 2.0,     // ft
  jumpDuration: 0.5,   // s
  crouchDepth: 1.5,    // ft (eye moves down)
  crouchSpeed: 5.0,    // ft/s
  mouseSensitivity: 0.003
};
const hintDiv = document.getElementById('hint');
function updateHint(){ hintDiv.style.display = devMode ? 'none' : 'block'; }
updateHint();

// --- Input ---
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  keys[e.key] = true;
  if (e.key === '`') { devMode = !devMode; updateHint(); }
  if (e.key.toLowerCase() === 'l') showLayerDiagram = !showLayerDiagram;
  if (e.key.toLowerCase() === 'm' && !devMode) {
    if (document.pointerLockElement === canvas) document.exitPointerLock();
    else canvas.requestPointerLock();
  }
  if (devMode) {
    switch (e.key) {
      case '1': settings.jumpHeight += 0.1; break;
      case '2': settings.jumpHeight = Math.max(0.1, settings.jumpHeight - 0.1); break;
      case '3': settings.jumpDuration += 0.05; break;
      case '4': settings.jumpDuration = Math.max(0.05, settings.jumpDuration - 0.05); break;
      case '5': settings.crouchSpeed += 0.5; break;
      case '6': settings.crouchSpeed = Math.max(0.5, settings.crouchSpeed - 0.5); break;
      case '7': settings.mouseSensitivity += 0.0005; break;
      case '8': settings.mouseSensitivity = Math.max(0.0005, settings.mouseSensitivity - 0.0005); break;
    }
  }
});
window.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
  keys[e.key] = false;
});
document.addEventListener('mousemove', e => {
  if (document.pointerLockElement === canvas) {
    player.angle += e.movementX * settings.mouseSensitivity;
    player.pitch -= e.movementY * settings.mouseSensitivity;
    const limit = Math.PI/2 - 0.01;
    player.pitch = Math.max(-limit, Math.min(limit, player.pitch));
  }
});

// --- Helpers ---
function inMap(x,y){ return x >= 0 && y >= 0 && x < MAP_W && y < MAP_H; }
function tileAt(x,y){ if (!inMap(Math.floor(x), Math.floor(y))) return 1; return map[Math.floor(y)][Math.floor(x)]; }

// --- Raycast (step) ---
function castRay(px, py, angle) {
  let rx = px, ry = py;
  const step = 0.02;
  let traveled = 0;
  while (traveled < MAX_RAY_DIST) {
    rx += Math.cos(angle) * step;
    ry += Math.sin(angle) * step;
    traveled += step;
    const tx = Math.floor(rx), ty = Math.floor(ry);
    if (!inMap(tx, ty)) return MAX_RAY_DIST;
    if (map[ty][tx] === 1) return Math.hypot(rx - px, ry - py);
  }
  return MAX_RAY_DIST;
}

// --- Collision ---
function isColliding(x,y) {
  const r = player.radius;
  const minX = Math.floor(x - r), maxX = Math.floor(x + r);
  const minY = Math.floor(y - r), maxY = Math.floor(y + r);
  for (let yy = minY; yy <= maxY; yy++) {
    for (let xx = minX; xx <= maxX; xx++) {
      if (!inMap(xx,yy)) return true;
      if (map[yy][xx] === 1) return true;
    }
  }
  return false;
}

// --- Dev map editing ---
canvas.addEventListener('click', e => {
  if (!devMode) return;
  const scale = 18, margin = 10;
  const mapWpx = MAP_W * scale, mapHpx = MAP_H * scale;
  const offX = canvas.width - mapWpx - margin, offY = canvas.height - mapHpx - margin;
  const mx = e.clientX, my = e.clientY;
  if (mx >= offX && mx < offX + mapWpx && my >= offY && my < offY + mapHpx) {
    const gx = Math.floor((mx - offX) / scale), gy = Math.floor((my - offY) / scale);
    if (inMap(gx,gy) && !(Math.floor(player.x) === gx && Math.floor(player.y) === gy)) {
      map[gy][gx] = map[gy][gx] === 1 ? 0 : 1;
    }
  }
});

// --- Physics & Input ---
function handleInput(delta) {
  const speed = settings.walkSpeed * delta; // ft per frame (treat 1 tile ≈ 1 ft)
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup']) { dx += Math.cos(player.angle) * speed; dy += Math.sin(player.angle) * speed; }
  if (keys['s'] || keys['arrowdown']) { dx -= Math.cos(player.angle) * speed; dy -= Math.sin(player.angle) * speed; }
  if (keys['a'] || keys['arrowleft']) { dx += Math.sin(player.angle) * speed; dy -= Math.cos(player.angle) * speed; }
  if (keys['d'] || keys['arrowright']) { dx -= Math.sin(player.angle) * speed; dy += Math.cos(player.angle) * speed; }

  const newX = player.x + dx, newY = player.y + dy;
  if (!isColliding(newX, player.y)) player.x = newX;
  if (!isColliding(player.x, newY)) player.y = newY;

  // Jump
  if ((keys[' '] || keys['space']) && player.onFloor) {
    const t = settings.jumpDuration;
    const h = settings.jumpHeight;
    const v0 = - (h + 0.5 * GRAVITY * t * t) / t; // negative = upward
    player.verticalVel = v0;
    player.onFloor = false;
  }
  // gravity
  player.verticalVel += GRAVITY * delta;
  player.eyeOffset += player.verticalVel * delta;
  if (player.eyeOffset >= 0) { player.eyeOffset = 0; player.verticalVel = 0; player.onFloor = true; }

  // crouch (ctrl)
  if (keys['control']) player.eyeOffset = Math.max(-settings.crouchDepth, player.eyeOffset - settings.crouchSpeed * delta);
  else player.eyeOffset = Math.min(0, player.eyeOffset + settings.crouchSpeed * delta);
}

// --- Rendering ---
// We'll do proper floor-casting (perspective correct) using projection math.

function renderWorld() {
  const w = canvas.width, h = canvas.height;
  // horizon uses pitch and eyeOffset (eyeOffset in feet -> pixels)
  const horizon = Math.floor(h / 2 + Math.tan(player.pitch) * h / 2 - player.eyeOffset * PIXELS_PER_FT);

  // clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,w,h);

  // ceiling
  ctx.fillStyle = '#777';
  ctx.fillRect(0,0,w, Math.max(0, Math.min(horizon, h)));

  // precompute
  const fov = Math.PI / 3;
  const halfW = w / 2;
  const halfH = h / 2;
  const projPlaneDist = halfH / Math.tan(fov / 2); // projection plane distance (pixels)
  const eyeHeight = PLAYER_HEIGHT_FT + player.eyeOffset; // in ft (map units)
  const MIN_DIST = 0.15;

  // wall casting per column
  for (let col = 0; col < w; col++) {
    const rayAngle = player.angle - fov/2 + (col / w) * fov;
    const dist = castRay(player.x, player.y, rayAngle);
    const corrected = Math.max(dist * Math.cos(rayAngle - player.angle), MIN_DIST);
    const wallHeightPx = Math.min(h, (h / corrected) * 0.8);
    const pitchOffsetPx = Math.tan(player.pitch) * halfH - player.eyeOffset * PIXELS_PER_FT;
    const half = wallHeightPx / 2;
    const yTop = Math.max(0, Math.floor(horizon - half + pitchOffsetPx));
    const yBottom = Math.min(h, Math.floor(horizon + half + pitchOffsetPx));

    // wall shade
    const shade = Math.max(18, Math.min(255, Math.floor(200 / corrected)));
    ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
    if (yBottom > yTop) ctx.fillRect(col, yTop, 1, Math.max(0, yBottom - yTop));

    // --- FLOORCASTING for this scanline row group (classic approach) ---
    // We'll compute the floor intersection for each screen row (y) below the wall bottom,
    // but to be efficient: compute per horizontal row (outside column loop) is typical,
    // however for simplicity and to be robust across pitch/eyeOffset we'll do per-column row iteration here.
    // (Performance is okay for single-file demo; can be optimized if desired.)

    // compute left/right ray directions for floorcasting at this column:
    // but the classic method uses rayDirLeft and rayDirRight once per row.
    // Here we approximate by computing for each pixel row below.

    // Instead of heavy per-pixel trig per column, we'll perform floor-casting per row outside the column loop.
    // To keep code clear and correct we break the per-column floor filling and handle floor-casting later.
    // So do nothing here for floor — floor will be painted in the dedicated floor-casting section after walls.
  }

  // --- FLOOR-CASTING (per-row approach for correct perspective) ---
  // We'll iterate screen rows from horizon+1 to h-1, compute rowDistance,
  // then compute left/right ray direction and step across columns to map world coords.

  // Precompute directions for left and right edge of the screen
  const dirX = Math.cos(player.angle), dirY = Math.sin(player.angle);
  const leftAngle = player.angle - fov/2;
  const rightAngle = player.angle + fov/2;
  const rayDirLeft = { x: Math.cos(leftAngle), y: Math.sin(leftAngle) };
  const rayDirRight = { x: Math.cos(rightAngle), y: Math.sin(rightAngle) };

  // For each screen row below horizon
  for (let screenY = Math.max(0, horizon); screenY < h; screenY++) {
    const p = screenY - halfH; // screenY relative to center
    const denom = (screenY - horizon);
    if (denom <= 0) continue; // skip rows above horizon

    // rowDistance in world units (tiles/ft)
    // formula: rowDistance = (eyeHeight * projPlaneDist) / (screenY - horizon)
    const rowDistance = (eyeHeight * projPlaneDist) / (screenY - horizon);

    // compute the real world step vector across the screen row
    const stepX = (rayDirRight.x - rayDirLeft.x) * (rowDistance / w);
    const stepY = (rayDirRight.y - rayDirLeft.y) * (rowDistance / w);

    // start world position at left of screen for this row
    let floorX = player.x + rayDirLeft.x * rowDistance;
    let floorY = player.y + rayDirLeft.y * rowDistance;

    // draw each column pixel for this row
    for (let col = 0; col < w; col++) {
      const mapX = Math.floor(floorX);
      const mapY = Math.floor(floorY);

      // choose floor color / pattern
      let base;
      if (!inMap(mapX, mapY)) {
        base = 30; // out-of-map darker
      } else {
        // simple checker pattern for visual depth (optional)
        const checker = ((mapX + mapY) & 1) === 0;
        base = checker ? 70 : 50;
      }

      // distance-based shading (farther = darker)
      const brightness = Math.max(10, Math.min(255, Math.floor(base + 160 / Math.max(0.5, rowDistance))));
      ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
      ctx.fillRect(col, screenY, 1, 1);

      // advance floor pos
      floorX += stepX;
      floorY += stepY;
    }
  }
}

// --- HUD & overlays ---
function renderHUD() {
  const scale = 18;
  const margin = 10;
  const mapWpx = MAP_W * scale, mapHpx = MAP_H * scale;
  const offX = canvas.width - mapWpx - margin, offY = canvas.height - mapHpx - margin;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(offX - 4, offY - 4, mapWpx + 8, mapHpx + 8);

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      ctx.fillStyle = map[y][x] === 1 ? '#111' : '#ddd';
      ctx.fillRect(offX + x * scale, offY + y * scale, scale - 1, scale - 1);
    }
  }

  const px = offX + player.x * scale;
  const py = offY + player.y * scale;
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(px, py, Math.max(2, scale / 4), 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = 'red';
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.lineTo(px + Math.cos(player.angle) * scale, py + Math.sin(player.angle) * scale);
  ctx.stroke();

  // info box
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(canvas.width - 220, canvas.height - 80, 210, 70);
  ctx.fillStyle = 'cyan';
  ctx.font = '14px monospace';
  const eyeLevelFt = (PLAYER_HEIGHT_FT + player.eyeOffset).toFixed(2);
  ctx.fillText(`Eye level: ${eyeLevelFt} ft`, canvas.width - 210, canvas.height - 50);
  ctx.fillStyle = 'white';
  ctx.fillText(`Pos: ${player.x.toFixed(2)}, ${player.y.toFixed(2)}`, canvas.width - 210, canvas.height - 32);
  ctx.fillText(`Angle: ${player.angle.toFixed(2)} rad`, canvas.width - 210, canvas.height - 16);
}

function renderFeaturesOverlay() {
  const margin = 10, overlayW = 300, overlayH = 180;
  const x = canvas.width - overlayW - margin, y = margin;
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(x, y, overlayW, overlayH);
  ctx.fillStyle = 'white';
  ctx.font = '14px monospace';
  const line = i => y + 20 + i * 18;
  ctx.fillText('FEATURES (Toggle key):', x + 10, line(0));
  ctx.fillStyle = devMode ? 'lime' : 'red';
  ctx.fillText('Dev Mode (`): ' + (devMode ? 'ON' : 'OFF'), x + 10, line(1));
  ctx.fillStyle = (!devMode && document.pointerLockElement === canvas) ? 'lime' : 'red';
  ctx.fillText('Mouse Look (M): ' + ((!devMode && document.pointerLockElement === canvas) ? 'ON' : 'OFF'), x + 10, line(2));
  ctx.fillStyle = keys[' '] ? 'lime' : 'red';
  ctx.fillText('Jump (Space)', x + 10, line(3));
  ctx.fillStyle = keys['control'] ? 'lime' : 'red';
  ctx.fillText('Crouch (Ctrl)', x + 10, line(4));
  ctx.fillStyle = showLayerDiagram ? 'lime' : 'red';
  ctx.fillText('Layer Diagram (L): ' + (showLayerDiagram ? 'ON' : 'OFF'), x + 10, line(5));
  ctx.fillStyle = 'cyan';
  ctx.fillText(`Eye Level: ${(PLAYER_HEIGHT_FT + player.eyeOffset).toFixed(2)} ft`, x + 10, line(6));
  ctx.fillStyle = 'white';
  ctx.fillText(`Floor-Ceiling: ${CEILING_HEIGHT_FT} ft`, x + 10, line(7));
}

function renderSettingsOverlay() {
  if (!devMode) return;
  const x = 10, y = 10;
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(x, y, 280, 140);
  ctx.fillStyle = 'white';
  ctx.font = '14px monospace';
  ctx.fillText('DEV SETTINGS:', x + 10, y + 20);
  ctx.fillStyle = 'yellow';
  ctx.fillText(`Jump Height (ft): ${settings.jumpHeight.toFixed(2)} (1/2)`, x + 10, y + 40);
  ctx.fillText(`Jump Duration (s): ${settings.jumpDuration.toFixed(2)} (3/4)`, x + 10, y + 60);
  ctx.fillText(`Crouch Depth (ft): ${settings.crouchDepth.toFixed(2)} (5/6)`, x + 10, y + 80);
  ctx.fillText(`Mouse Sensitivity: ${settings.mouseSensitivity.toFixed(4)} (7/8)`, x + 10, y + 100);
  ctx.fillStyle = 'white';
  ctx.fillText('Use 1-8 to tweak', x + 10, y + 120);
}

// --- Layer diagram ---
function renderLayerDiagram() {
  if (!showLayerDiagram) return;
  ctx.fillStyle = 'rgba(0,0,255,0.18)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const scale = 18, mapWpx = MAP_W*scale, mapHpx = MAP_H*scale;
  const offX = canvas.width - mapWpx - 10, offY = canvas.height - mapHpx - 10;
  ctx.fillStyle = 'rgba(0,255,0,0.25)'; ctx.fillRect(offX, offY, mapWpx, mapHpx);
  ctx.fillStyle = 'black'; ctx.font = '14px monospace'; ctx.fillText('HUD', offX + 6, offY + 18);
  ctx.fillStyle = 'rgba(255,255,0,0.22)'; ctx.fillRect(canvas.width - 310, 10, 300, 180);
  ctx.fillStyle = 'black'; ctx.fillText('Feature Overlay', canvas.width - 300, 30);
  ctx.fillStyle = 'rgba(255,165,0,0.22)'; ctx.fillRect(10, 10, 280, 140);
  ctx.fillStyle = 'black'; ctx.fillText('Settings Overlay', 20, 30);
  ctx.fillStyle = 'white'; ctx.font = '16px monospace'; ctx.fillText('Layer Diagram ACTIVE (toggle L)', 20, 20);
}

// --- Main loop ---
let last = performance.now();
function loop(now) {
  const dt = Math.min(0.05, (now - last) / 1000); last = now;
  handleInput(dt);
  renderWorld();
  renderHUD();
  renderFeaturesOverlay();
  renderSettingsOverlay();
  renderLayerDiagram();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
