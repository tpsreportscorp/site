<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini ANKI SPA - Mobile Friendly</title>
<style>
/* Base styling */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 15px;
    background: #f0f0f0;
    font-size: 4vw; /* responsive font size */
}

h1,h2 {
    margin-bottom: 10px;
    text-align: center;
    font-size: 6vw;
}

input {
    margin: 5px 0;
    padding: 3vw;
    width: 100%;
    font-size: 4vw;
    box-sizing: border-box;
    border-radius: 8px;
    border: 1px solid #ccc;
}

button {
    margin: 5px 0;
    padding: 3vw;
    font-size: 4vw;
    cursor: pointer;
    border-radius: 8px;
    border: none;
    background: #4CAF50;
    color: #fff;
}

button:hover { background: #45a049; }

ul { list-style: none; padding: 0; }

li {
    padding: 3vw;
    background: #fff;
    margin: 2vw 0;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    font-size: 4vw;
    min-height: 12vw;
}

li span { cursor: pointer; flex-grow:1; min-width:60%; }

.edit-btn, .delete-btn {
    margin-left: 2vw;
    font-size: 3.5vw;
    padding: 2vw 3vw;
    border-radius: 6px;
    border: none;
}

.edit-btn { background: #2196F3; color: #fff; }
.edit-btn:hover { background: #1976D2; }
.delete-btn { background: #f44336; color: #fff; }
.delete-btn:hover { background: #d32f2f; }

#card-manager, #study-mode { display: none; }

/* Card container styling */
.card-container {
    perspective: 1000px;
    margin: 5vw auto;
    width: 95%;
    max-width: 500px;
}

.card {
    width: 100%;
    height: 50vh; /* responsive height */
    line-height: 50vh;
    text-align: center;
    border: 1px solid #ccc;
    background: #fff;
    border-radius: 12px;
    cursor: pointer;
    font-size: 5vw;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    position: relative;
    padding: 2vw;
    box-sizing: border-box;
}

.card.flipped { transform: rotateY(180deg); }

.card-front, .card-back {
    position: absolute;
    width:100%;
    height:100%;
    backface-visibility: hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:2vw;
    box-sizing:border-box;
    text-align:center;
    word-wrap: break-word;
    font-size:5vw;
}

.card-back { transform: rotateY(180deg); }

/* Study mode buttons */
#study-mode div button {
    display:inline-block;
    min-width: 40%;
    height: 12vw;
    margin: 3vw 2vw;
    font-size: 4vw;
}

/* Responsive tweaks */
@media (max-width: 500px) {
    body { font-size: 5vw; }
    h1,h2 { font-size: 8vw; }
    input { padding: 4vw; font-size:5vw; }
    button { padding:4vw; font-size:5vw; }
    li { font-size:5vw; padding:4vw; min-height:15vw; }
    .edit-btn, .delete-btn { font-size:4.5vw; padding:3vw 4vw; }
    .card { height: 45vh; line-height: 45vh; font-size:6vw; }
    .card-front, .card-back { font-size:6vw; }
    #study-mode div button { height: 14vw; font-size:5vw; min-width:45%; }
}
</style>
</head>
<body>

<h1>Mini ANKI SPA</h1>

<div id="deck-manager">
  <input type="text" id="deck-name" placeholder="New deck name">
  <button id="create-deck">Create Deck</button>
  <ul id="deck-list"></ul>
  <div>
    <button id="export-data">Export Data</button>
    <input type="file" id="import-file">
  </div>
</div>

<div id="card-manager">
  <h2 id="current-deck-name"></h2>
  <input type="text" id="card-front" placeholder="Front">
  <input type="text" id="card-back" placeholder="Back">
  <button id="add-card">Add Card</button>
  <button id="back-to-decks">Back to Decks</button>
  <ul id="card-list"></ul>
  <button id="study-deck">Study Deck</button>
</div>

<div id="study-mode">
  <h2 id="study-deck-title"></h2>
  <div class="card-container">
      <div id="flashcard" class="card">
          <div class="card-front"></div>
          <div class="card-back"></div>
      </div>
  </div>
  <div style="text-align:center;">
      <button id="flip-card">Flip</button>
      <button id="again">Again</button>
      <button id="good">Good</button>
      <button id="easy">Easy</button>
      <button id="end-study">End Study</button>
  </div>
</div>

<script>
// ---------------- IndexedDB Setup ----------------
const dbName = "ankiDB";
const dbVersion = 3; // version bump for new features
let db;
async function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, dbVersion);
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains("decks")) db.createObjectStore("decks", { keyPath: "name" });
            if (!db.objectStoreNames.contains("cards")) {
                const store = db.createObjectStore("cards", { keyPath: "id", autoIncrement: true });
                store.createIndex("deck", "deck", { unique: false });
            }
        };
        request.onsuccess = (event) => { db = event.target.result; resolve(db); };
        request.onerror = (event) => reject(event.target.error);
    });
}

// ---------------- Deck Functions ----------------
async function addDeck(name) {
    const tx = db.transaction("decks", "readwrite");
    tx.objectStore("decks").add({ name });
    await tx.complete;
}

async function updateDeckName(oldName, newName) {
    const tx1 = db.transaction("decks", "readwrite");
    const storeDecks = tx1.objectStore("decks");
    storeDecks.delete(oldName);
    storeDecks.add({ name:newName });
    await tx1.complete;

    const cards = await getCards(oldName);
    const tx2 = db.transaction("cards", "readwrite");
    const storeCards = tx2.objectStore("cards");
    for (const card of cards) {
        card.deck = newName;
        storeCards.put(card);
    }
    await tx2.complete;
}

async function deleteDeck(name) {
    const tx1 = db.transaction("decks", "readwrite");
    tx1.objectStore("decks").delete(name);
    await tx1.complete;

    const cards = await getCards(name);
    const tx2 = db.transaction("cards", "readwrite");
    const storeCards = tx2.objectStore("cards");
    for (const card of cards) storeCards.delete(card.id);
    await tx2.complete;
}

async function getDecks() {
    return new Promise((resolve, reject) => {
        const tx = db.transaction("decks", "readonly");
        const store = tx.objectStore("decks");
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result.map(d => d.name));
        request.onerror = () => reject(request.error);
    });
}

// ---------------- Card Functions ----------------
async function addCardToDB(deck, front, back) {
    const tx = db.transaction("cards", "readwrite");
    const store = tx.objectStore("cards");
    const card = { deck, front, back, interval:0, repetitions:0, EF:2.5, nextReview: Date.now() };
    store.add(card);
    await tx.complete;
}

async function getCards(deck) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction("cards", "readonly");
        const store = tx.objectStore("cards");
        const index = store.index("deck");
        const request = index.getAll(deck);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

async function updateCard(card) {
    const tx = db.transaction("cards", "readwrite");
    const store = tx.objectStore("cards");
    store.put(card);
    await tx.complete;
}

async function deleteCard(id) {
    const tx = db.transaction("cards", "readwrite");
    tx.objectStore("cards").delete(id);
    await tx.complete;
}

// ---------------- Import/Export ----------------
async function exportData() {
    const decks = await getDecks();
    const cards = [];
    for (const deck of decks) {
        const deckCards = await getCards(deck);
        cards.push(...deckCards);
    }
    const data = { decks, cards };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'anki_data.json';
    a.click();
    URL.revokeObjectURL(url);
}

async function importData(file) {
    const text = await file.text();
    const data = JSON.parse(text);
    if (!data.decks || !data.cards) return;
    for (const deck of data.decks) { try { await addDeck(deck); } catch(e){} }
    const tx = db.transaction("cards", "readwrite");
    const store = tx.objectStore("cards");
    for (const card of data.cards) store.put(card);
    await tx.complete;
    renderDecks();
}

// ---------------- Deck & Card UI ----------------
let currentDeck = null;
let studyCards = [];
let currentCardIndex = 0;
let showingFront = true;

const deckList = document.getElementById('deck-list');
const cardList = document.getElementById('card-list');
const deckNameInput = document.getElementById('deck-name');
const cardFrontInput = document.getElementById('card-front');
const cardBackInput = document.getElementById('card-back');
const currentDeckName = document.getElementById('current-deck-name');
const studyDeckTitle = document.getElementById('study-deck-title');

async function renderDecks() {
    const decks = await getDecks();
    deckList.innerHTML = '';
    decks.forEach(deck => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = deck;
        span.addEventListener('click', () => openDeck(deck));
        li.appendChild(span);

        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.className = 'edit-btn';
        editBtn.addEventListener('click', async () => {
            const newName = prompt("New deck name:", deck);
            if (newName && newName !== deck) {
                await updateDeckName(deck, newName);
                if (currentDeck === deck) currentDeck = newName;
                renderDecks();
                if(currentDeck === newName) openDeck(newName);
            }
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete-btn';
        deleteBtn.addEventListener('click', async () => {
            if (confirm(`Delete deck "${deck}" and all its cards?`)) {
                await deleteDeck(deck);
                if (currentDeck === deck) { currentDeck = null; document.getElementById('card-manager').style.display="none"; document.getElementById('deck-manager').style.display="block"; }
                renderDecks();
            }
        });

        li.appendChild(editBtn);
        li.appendChild(deleteBtn);
        deckList.appendChild(li);
    });
}

async function renderCards() {
    const cards = await getCards(currentDeck);
    cardList.innerHTML = '';
    cards.forEach(card => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = `Front: ${card.front} | Back: ${card.back}`;
        li.appendChild(span);

        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.className='edit-btn';
        editBtn.addEventListener('click', async () => {
            const newFront = prompt("New front text:", card.front);
            const newBack = prompt("New back text:", card.back);
            if (newFront && newBack) {
                card.front = newFront;
                card.back = newBack;
                await updateCard(card);
                renderCards();
            }
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className='delete-btn';
        deleteBtn.addEventListener('click', async () => {
            if(confirm("Delete this card?")) {
                await deleteCard(card.id);
                renderCards();
            }
        });

        li.appendChild(editBtn);
        li.appendChild(deleteBtn);
        cardList.appendChild(li);
    });
}

async function openDeck(deck) {
    currentDeck = deck;
    currentDeckName.textContent = deck;
    document.getElementById('deck-manager').style.display = "none";
    document.getElementById('card-manager').style.display = "block";
    renderCards();
}

// ---------------- Event Listeners ----------------
document.getElementById('create-deck').addEventListener('click', async () => {
    const name = deckNameInput.value.trim();
    if (!name) return;
    try { await addDeck(name); } catch(e) {}
    deckNameInput.value = '';
    renderDecks();
    openDeck(name);
});

document.getElementById('add-card').addEventListener('click', async () => {
    const front = cardFrontInput.value.trim();
    const back = cardBackInput.value.trim();
    if (!front || !back) return;
    await addCardToDB(currentDeck, front, back);
    cardFrontInput.value = '';
    cardBackInput.value = '';
    renderCards();
});

document.getElementById('back-to-decks').addEventListener('click', () => {
    currentDeck = null;
    document.getElementById('card-manager').style.display = "none";
    document.getElementById('deck-manager').style.display = "block";
    renderDecks();
});

document.getElementById('study-deck').addEventListener('click', async () => {
    studyCards = await getCards(currentDeck);
    studyCards = studyCards.filter(c => Date.now() >= c.nextReview);
    if (studyCards.length === 0) { alert("No cards due for review!"); return; }
    currentCardIndex = 0;
    showingFront = true;
    document.getElementById('card-manager').style.display = "none";
    document.getElementById('study-mode').style.display = "block";
    studyDeckTitle.textContent = currentDeck;
    showCard();
});

document.getElementById('export-data').addEventListener('click', exportData);
document.getElementById('import-file').addEventListener('change', e => importData(e.target.files[0]));

// ---------------- Study Mode ----------------
const flashcard = document.getElementById('flashcard');
function showCard() {
    if (currentCardIndex >= studyCards.length) {
        alert("All due cards reviewed!");
        document.getElementById('study-mode').style.display = "none";
        document.getElementById('card-manager').style.display = "block";
        return;
    }
    const card = studyCards[currentCardIndex];
    flashcard.querySelector(".card-front").textContent = card.front;
    flashcard.querySelector(".card-back").textContent = card.back;
    flashcard.classList.remove("flipped");
    showingFront = true;
}
flashcard.addEventListener('click', () => flashcard.classList.toggle("flipped"));
document.getElementById('flip-card').addEventListener('click', () => flashcard.classList.toggle("flipped"));

// ---------------- SM-2 Algorithm ----------------
function reviewCardSM2(card, quality) {
    const now = Date.now();
    if (quality < 3) { card.repetitions = 0; card.interval = 1; }
    else { card.repetitions += 1; if (card.repetitions===1) card.interval=1; else if(card.repetitions===2) card.interval=6; else card.interval = Math.round(card.interval*card.EF);}
    card.EF = card.EF + (0.1 - (5-quality)*(0.08+(5-quality)*0.02));
    if(card.EF<1.3) card.EF=1.3;
    card.nextReview = now + card.interval*24*60*60*1000;
    updateCard(card);
}
function handleReviewSM2(q){const card=studyCards[currentCardIndex];reviewCardSM2(card,q);currentCardIndex++;showCard();}
document.getElementById('again').addEventListener('click',()=>handleReviewSM2(2));
document.getElementById('good').addEventListener('click',()=>handleReviewSM2(4));
document.getElementById('easy').addEventListener('click',()=>handleReviewSM2(5));
document.getElementById('end-study').addEventListener('click',()=>{
    document.getElementById('study-mode').style.display="none";
    document.getElementById('card-manager').style.display="block";
});

// ---------------- Initialize ----------------
openDB().then(renderDecks);
</script>
</body>
</html>
